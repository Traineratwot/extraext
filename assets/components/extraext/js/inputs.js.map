{"version":3,"names":[],"mappings":"","sources":["assets/components/extraext/js/inputs.js"],"sourcesContent":["extraExt.inputs = {}\n//modCombo\nextraExt.inputs.modCombo = {}\nextraExt.inputs.modCombo.xtype = 'extraExt-modCombo'\nextraExt.requireConfigField[extraExt.inputs.modCombo.xtype] = [\n\t'action',\n\t'displayField',\n\t'valueField',\n\t'fields',\n\t'url',\n]\nextraExt.xTypes[extraExt.inputs.modCombo.xtype] = function(config) {\n\tconfig = config || {}\n\tvar requireConfigField = extraExt.requireConfigField[this.xtype || config.xtype].slice()\n\tvar errorConfig = []\n\tthis.ident = config.ident || 'mecnewsletter' + Ext.id()\n\tExt.applyIf(config, {\n\t\turl: MODx.config.connector_url,\n\t\tanchor: '99%',\n\t\teditable: true,\n\t\tpageSize: 20,\n\t\tmode: 'remote',\n\t\tfields: ['id'],\n\t\thiddenName: config.name,\n\t\tdisplayField: 'id',\n\t\tvalueField: 'id',\n\t\tpreventRender: true,\n\t\tforceSelection: true,\n\t\tenableKeyEvents: true,\n\t})\n\tconfig.baseParams = Object.assign({\n\t\taction: config.action\n\t}, config.baseParams)\n\n\tconfig.store = new Ext.data.JsonStore({\n\t\tid: (config.name || Ext.id()) + '-store'\n\t\t, root: 'results'\n\t\t, autoLoad: true\n\t\t, autoSave: false\n\t\t, totalProperty: 'total'\n\t\t, fields: config.fields\n\t\t, url: config.url\n\t\t, baseParams: config.baseParams\n\t})\n\tfor(const key of requireConfigField) {\n\t\tif(config.hasOwnProperty(key)) {\n\t\t\tif(extraExt.empty(config[key])) {\n\t\t\t\terrorConfig.push(key)\n\t\t\t}\n\t\t} else {\n\t\t\terrorConfig.push(key)\n\t\t}\n\n\t}\n\tif(errorConfig.length > 0) {\n\t\tconsole.error(`ExtraExt: invalid require config [${this.xtype || config.xtype}]`, errorConfig)\n\t\treturn false\n\t}\n\textraExt.xTypes[extraExt.inputs.modCombo.xtype].superclass.constructor.call(this, config) // Магия\n}\nExt.extend(extraExt.xTypes[extraExt.inputs.modCombo.xtype], MODx.combo.ComboBox) // Расширяем MODX.ComboBox\nExt.reg(extraExt.inputs.modCombo.xtype, extraExt.xTypes[extraExt.inputs.modCombo.xtype]) // Регистрируем новый xtype\n//modComboSuper\nextraExt.inputs.modComboSuper = {}\nextraExt.inputs.modComboSuper.requireConfigField = [\n\t'action',\n\t'displayField',\n\t'valueField',\n\t'fields',\n\t'url',\n]\nextraExt.inputs.modComboSuper.xtype = 'extraExt-modComboSuper'\nextraExt.xTypes[extraExt.inputs.modComboSuper.xtype] = function(config) {\n\tvar requireConfigField = extraExt.inputs.modComboSuper.requireConfigField.slice()\n\tvar errorConfig = []\n\tconfig = config || {}\n\tconfig.url = MODx.config.connector_url\n\tExt.applyIf(config, {\n\t\txtype: 'superboxselect'\n\t\t, allowBlank: true\n\t\t, msgTarget: 'under'\n\t\t, allowAddNewData: true\n\t\t, addNewDataOnBlur: true\n\t\t, width: '100%'\n\t\t, editable: true\n\t\t, pageSize: 20\n\t\t, preventRender: true\n\t\t, forceSelection: true\n\t\t, enableKeyEvents: true\n\t\t, minChars: 2\n\t\t, hiddenName: config.name + '[]'\n\t\t, mode: 'remote'\n\t\t, displayField: 'id'\n\t\t, valueField: 'id'\n\t\t, triggerAction: 'all'\n\t\t, extraItemCls: 'x-tag'\n\t\t, expandBtnCls: 'x-form-trigger'\n\t\t, clearBtnCls: 'x-form-trigger'\n\t\t, listeners: {\n\t\t\tnewitem: function(config, v, f) {bs.addItem({tag: v})}\n\t\t}\n\t\t, renderTo: Ext.getBody()\n\t})\n\tif(!config.hasOwnProperty('id') || !config.id) {\n\t\tconfig.id = Ext.id()\n\t}\n\tconfig.baseParams = Object.assign({\n\t\taction: config.action\n\t}, config.baseParams)\n\tconfig.store = new Ext.data.JsonStore({\n\t\tid: (config.name || Ext.id()) + '-store'\n\t\t, root: 'results'\n\t\t, autoLoad: true\n\t\t, autoSave: false\n\t\t, totalProperty: 'total'\n\t\t, fields: config.fields\n\t\t, url: config.url\n\t\t, baseParams: config.baseParams\n\t})\n\tif(config.hasOwnProperty('table') && config.table.hasOwnProperty('requestDataType') && config.table.requestDataType =='json') {\n\t\tconfig.hiddenName =\tconfig.name\n\t} else {\n\t\tconfig.hiddenName =\tconfig.name + '[]'\n\t}\n\textraExt.xTypes[extraExt.inputs.modComboSuper.xtype].superclass.constructor.call(this, config)\n}\nExt.extend(extraExt.xTypes[extraExt.inputs.modComboSuper.xtype], Ext.ux.form.SuperBoxSelect)\nExt.reg(extraExt.inputs.modComboSuper.xtype, extraExt.xTypes[extraExt.inputs.modComboSuper.xtype])\n//popup\n// extraExt.inputs.popup = {}\n// extraExt.inputs.popup.xtype = 'extraExt-popup'\n// extraExt.xTypes[extraExt.inputs.popup.xtype] = Ext.extend(Ext.form.Field, {\n// \tgrow: false,\n// \tgrowMin: 30,\n// \tgrowMax: 800,\n// \tvtype: null,\n// \tmaskRe: null,\n// \tdisableKeyFilter: false,\n// \tallowBlank: true,\n// \tminLength: 0,\n// \tmaxLength: Number.MAX_VALUE,\n// \tminLengthText: 'The minimum length for this field is {0}',\n// \tmaxLengthText: 'The maximum length for this field is {0}',\n// \tselectOnFocus: false,\n// \tblankText: 'This field is required',\n// \tvalidator: null,\n// \tregex: null,\n// \tregexText: '',\n// \temptyText: null,\n// \temptyClass: 'x-form-empty-field',\n// \tinitComponent: function() {\n//\n// \t\tExt.form.TextField.superclass.initComponent.call(this)\n// \t\tthis.addEvents('autosize', 'keydown', 'keyup', 'keypress')\n// \t},\n// \tinitEvents: function() {\n// \t\tExt.form.TextField.superclass.initEvents.call(this)\n// \t\t// if(this.validationEvent == 'keyup') {\n// \t\t// \tthis.validationTask = new Ext.util.DelayedTask(this.validate, this)\n// \t\t// \tthis.mon(this.el, 'keyup', this.filterValidation, this)\n// \t\t// } else {if(this.validationEvent !== false && this.validationEvent != 'blur') {this.mon(this.el, this.validationEvent, this.validate, this, {buffer: this.validationDelay})}}\n// \t\t// if(this.selectOnFocus || this.emptyText) {\n// \t\t// \tthis.mon(this.el, 'mousedown', this.onMouseDown, this)\n// \t\t// \tif(this.emptyText) {this.applyEmptyText()}\n// \t\t// }\n// \t\t// if(this.maskRe || (this.vtype && this.disableKeyFilter !== true && (this.maskRe = Ext.form.VTypes[this.vtype + 'Mask']))) {this.mon(this.el, 'keypress', this.filterKeys, this)}\n// \t\t// if(this.grow) {\n// \t\t// \tthis.mon(this.el, 'keyup', this.onKeyUpBuffered, this, {buffer: 50})\n// \t\t// \tthis.mon(this.el, 'click', this.autoSize, this)\n// \t\t// }\n// \t\t// if(this.enableKeyEvents) {\n// \t\t// \tthis.mon(this.el, {\n// \t\t// \t\tscope: this,\n// \t\t// \t\tkeyup: this.onKeyUp,\n// \t\t// \t\tkeydown: this.onKeyDown,\n// \t\t// \t\tkeypress: this.onKeyPress\n// \t\t// \t})\n// \t\t// }\n// \t},\n// \tonMouseDown: function(a) {\n//\n// \t\tif(!this.hasFocus) {\n// \t\t\tthis.mon(this.el, 'mouseup', Ext.emptyFn, this, {\n// \t\t\t\tsingle: true,\n// \t\t\t\tpreventDefault: true\n// \t\t\t})\n// \t\t}\n// \t},\n// \tprocessValue: function(a) {\n//\n// \t\tif(this.stripCharsRe) {\n// \t\t\tvar b = a.replace(this.stripCharsRe, '')\n// \t\t\tif(b !== a) {\n// \t\t\t\tthis.setRawValue(b)\n// \t\t\t\treturn b\n// \t\t\t}\n// \t\t}\n// \t\treturn a\n// \t},\n// \tfilterValidation: function(a) {\n//\n// \t\tif(!a.isNavKeyPress()) {this.validationTask.delay(this.validationDelay)}\n// \t},\n// \tonDisable: function() {\n//\n// \t\tExt.form.TextField.superclass.onDisable.call(this)\n// \t\tif(Ext.isIE) {this.el.dom.unselectable = 'on'}\n// \t},\n// \tonEnable: function() {\n//\n// \t\tExt.form.TextField.superclass.onEnable.call(this)\n// \t\tif(Ext.isIE) {this.el.dom.unselectable = ''}\n// \t},\n// \tonKeyUpBuffered: function(a) {\n//\n// \t\tif(this.doAutoSize(a)) {this.autoSize()}\n// \t},\n// \tdoAutoSize: function(a) {\n//\n// \t\treturn !a.isNavKeyPress()\n// \t},\n// \tonKeyUp: function(a) {\n//\n// \t\tthis.fireEvent('keyup', this, a)\n// \t},\n// \tonKeyDown: function(a) {\n//\n// \t\tthis.fireEvent('keydown', this, a)\n// \t},\n// \tonKeyPress: function(a) {\n//\n// \t\tthis.fireEvent('keypress', this, a)\n// \t},\n// \treset: function() {\n//\n// \t\tExt.form.TextField.superclass.reset.call(this)\n// \t\tthis.applyEmptyText()\n// \t},\n// \tapplyEmptyText: function() {\n//\n// \t\tif(this.rendered && this.emptyText && this.getRawValue().length < 1 && !this.hasFocus) {\n// \t\t\tthis.setRawValue(this.emptyText)\n// \t\t\tthis.el.addClass(this.emptyClass)\n// \t\t}\n// \t},\n// \tpreFocus: function() {\n// \t\tconsole.info('preFocus', this)\n// \t\tvar a = this.el, b\n// \t\tif(this.emptyText) {\n// \t\t\tif(a.dom.value == this.emptyText) {\n// \t\t\t\tthis.setRawValue('')\n// \t\t\t\tb = true\n// \t\t\t}\n// \t\t\ta.removeClass(this.emptyClass)\n// \t\t}\n// \t},\n// \tpostBlur: function() {\n// \t\tconsole.info('postBlur', this)\n// \t\tthis.applyEmptyText()\n// \t},\n// \tfilterKeys: function(b) {\n//\n// \t\tif(b.ctrlKey) {return}\n// \t\tvar a = b.getKey()\n// \t\tif(Ext.isGecko && (b.isNavKeyPress() || a == b.BACKSPACE || (a == b.DELETE && b.button == -1))) {return}\n// \t\tvar c = String.fromCharCode(b.getCharCode())\n// \t\tif(!Ext.isGecko && b.isSpecialKey() && !c) {return}\n// \t\tif(!this.maskRe.test(c)) {b.stopEvent()}\n// \t},\n// \tsetValue: function(a) {\n//\n// \t\tif(this.emptyText && this.el && !Ext.isEmpty(a)) {this.el.removeClass(this.emptyClass)}\n// \t\tExt.form.TextField.superclass.setValue.apply(this, arguments)\n// \t\tthis.applyEmptyText()\n// \t\tthis.autoSize()\n// \t\treturn this\n// \t},\n// \tgetErrors: function(a) {\n//\n// \t\tvar d = Ext.form.TextField.superclass.getErrors.apply(this, arguments)\n// \t\ta = Ext.isDefined(a) ? a : this.processValue(this.getRawValue())\n// \t\tif(Ext.isFunction(this.validator)) {\n// \t\t\tvar c = this.validator(a)\n// \t\t\tif(c !== true) {d.push(c)}\n// \t\t}\n// \t\tif(a.length < 1 || a === this.emptyText) {if(this.allowBlank) {return d} else {d.push(this.blankText)}}\n// \t\tif(!this.allowBlank && (a.length < 1 || a === this.emptyText)) {d.push(this.blankText)}\n// \t\tif(a.length < this.minLength) {d.push(String.format(this.minLengthText, this.minLength))}\n// \t\tif(a.length > this.maxLength) {d.push(String.format(this.maxLengthText, this.maxLength))}\n// \t\tif(this.vtype) {\n// \t\t\tvar b = Ext.form.VTypes\n// \t\t\tif(!b[this.vtype](a, this)) {d.push(this.vtypeText || b[this.vtype + 'Text'])}\n// \t\t}\n// \t\tif(this.regex && !this.regex.test(a)) {d.push(this.regexText)}\n// \t\treturn d\n// \t},\n// \tselectText: function(h, a) {\n//\n// \t\tvar c = this.getRawValue()\n// \t\tvar e = false\n// \t\tif(c.length > 0) {\n// \t\t\th = h === undefined ? 0 : h\n// \t\t\ta = a === undefined ? c.length : a\n// \t\t\tvar g = this.el.dom\n// \t\t\tif(g.setSelectionRange) {g.setSelectionRange(h, a)} else {\n// \t\t\t\tif(g.createTextRange) {\n// \t\t\t\t\tvar b = g.createTextRange()\n// \t\t\t\t\tb.moveStart('character', h)\n// \t\t\t\t\tb.moveEnd('character', a - c.length)\n// \t\t\t\t\tb.select()\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\te = Ext.isGecko || Ext.isOpera\n// \t\t} else {e = true}\n// \t\tif(e) {this.focus()}\n// \t},\n// \tautoSize: function() {\n//\n// \t\tif(!this.grow || !this.rendered) {return}\n// \t\tif(!this.metrics) {this.metrics = Ext.util.TextMetrics.createInstance(this.el)}\n// \t\tvar c = this.el\n// \t\tvar b = c.dom.value\n// \t\tvar e = document.createElement('div')\n// \t\te.appendChild(document.createTextNode(b))\n// \t\tb = e.innerHTML\n// \t\tExt.removeNode(e)\n// \t\te = null\n// \t\tb += '&#160;'\n// \t\tvar a = Math.min(this.growMax, Math.max(this.metrics.getWidth(b) + 10, this.growMin))\n// \t\tthis.el.setWidth(a)\n// \t\tthis.fireEvent('autosize', this, a)\n// \t},\n// \tonDestroy: function() {\n//\n// \t\tif(this.validationTask) {\n// \t\t\tthis.validationTask.cancel()\n// \t\t\tthis.validationTask = null\n// \t\t}\n// \t\tExt.form.TextField.superclass.onDestroy.call(this)\n// \t}\n// })\n// Ext.reg(extraExt.inputs.popup.xtype, extraExt.xTypes[extraExt.inputs.popup.xtype])\n//регистрируем кастомный способ отправки\nextraExt.inputs.Submit = function(b, a) {extraExt.inputs.Submit.superclass.constructor.call(this, b, a)}\nExt.extend(extraExt.inputs.Submit, Ext.form.Action.Submit, {\n\ttype: 'submit', run: function() {\n\t\tvar e = this.options, g = this.getMethod(), d = g == 'GET'\n\t\tif(e.clientValidation === false || this.form.isValid()) {\n\t\t\tif(e.submitEmptyText === false) {\n\t\t\t\tvar a = this.form.items, c = [], b = function(h) {\n\t\t\t\t\tif(h.el.getValue() == h.emptyText) {\n\t\t\t\t\t\tc.push(h)\n\t\t\t\t\t\th.el.dom.value = ''\n\t\t\t\t\t}\n\t\t\t\t\tif(h.isComposite && h.rendered) {h.items.each(b)}\n\t\t\t\t}\n\t\t\t\ta.each(b)\n\t\t\t}\n\n\t\t\tvar params = this.form.baseParams\n\t\t\tparams.data = Ext.util.JSON.encode(this.form.getValues())\n\t\t\tExt.Ajax.request(Ext.apply(this.createCallback(e), {\n\t\t\t\tparams: params,\n\t\t\t\turl: this.getUrl(d),\n\t\t\t\tmethod: g,\n\t\t\t\theaders: e.headers,\n\t\t\t\tisUpload: this.form.fileUpload\n\t\t\t}))\n\t\t\tif(e.submitEmptyText === false) {Ext.each(c, function(h) {if(h.applyEmptyText) {h.applyEmptyText()}})}\n\t\t} else {\n\t\t\tif(e.clientValidation !== false) {\n\t\t\t\tthis.failureType = Ext.form.Action.CLIENT_INVALID\n\t\t\t\tthis.form.afterAction(this, false)\n\t\t\t}\n\t\t}\n\t}\n})\n//# sourceMappingURL=inputs.js.map\n"],"file":"inputs.js"}